diff -rupNb gcc-5.3.0-libgcc/config.sub gcc-5.3.0-ps2/config.sub
--- gcc-5.3.0-libgcc/config.sub	2015-01-02 17:30:21.000000000 +0800
+++ gcc-5.3.0-ps2/config.sub	2016-03-27 20:04:47.567691096 +0800
@@ -765,6 +765,10 @@ case $basic_machine in
 		basic_machine=i386-unknown
 		os=-vsta
 		;;
+	iop)
+		basic_machine=mipsel-scei
+		os=-irx
+		;;
 	iris | iris4d)
 		basic_machine=mips-sgi
 		case $os in
@@ -1393,7 +1397,8 @@ case $os in
 	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
 	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
 	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \
-	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops* | -es* | -tirtos*)
+	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops* | -es* | -tirtos* \
+	      | -irx*)
 	# Remember, each alternative MUST END IN *, to match a version number.
 		;;
 	-qnx*)
diff -rupNb gcc-5.3.0-libgcc/configure gcc-5.3.0-ps2/configure
--- gcc-5.3.0-libgcc/configure	2015-05-04 01:29:57.000000000 +0800
+++ gcc-5.3.0-ps2/configure	2016-03-27 20:04:47.571691096 +0800
@@ -3402,6 +3402,8 @@ case "${target}" in
     ;;
   mips*-*-linux*)
     ;;
+  mipsel-*-irx*)
+    ;;
   powerpc*-*-linux*)
     ;;
   powerpc-*-darwin*)
diff -rupNb gcc-5.3.0-libgcc/configure.ac gcc-5.3.0-ps2/configure.ac
--- gcc-5.3.0-libgcc/configure.ac	2015-05-04 01:29:57.000000000 +0800
+++ gcc-5.3.0-ps2/configure.ac	2016-03-27 20:04:47.575691096 +0800
@@ -749,6 +749,8 @@ case "${target}" in
     ;;
   mips*-*-linux*)
     ;;
+  mipsel-*-irx*)
+    ;;
   powerpc*-*-linux*)
     ;;
   powerpc-*-darwin*)
diff -rupNb gcc-5.3.0-libgcc/gcc/config/mips/5900.md gcc-5.3.0-ps2/gcc/config/mips/5900.md
--- gcc-5.3.0-libgcc/gcc/config/mips/5900.md	1970-01-01 07:30:00.000000000 +0730
+++ gcc-5.3.0-ps2/gcc/config/mips/5900.md	2016-03-27 18:05:24.000000000 +0800
@@ -0,0 +1,152 @@
+;; Copyright (C) 2002-2015 Free Software Foundation, Inc.
+;;
+;; This file is part of GCC.
+;;
+;; GCC is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
+;;
+;; GCC is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+;;
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+;;
+;; R5900 instruction patterns and pipeline tuning.
+
+(define_insn_reservation "r5900_hilo1" 1
+  (eq_attr "type" "mfhi1,mflo1,mthi1,mtlo1")
+  "imuldiv*3")
+
+;; 128-bit vectors of words, halfwords and bytes.
+(define_mode_iterator MMI_VWHB [V4SI V8HI V16QI])
+
+;; 128-bit vectors of words and halfwords
+(define_mode_iterator MMI_VWH [V4SI V8HI])
+
+;; Suffixes corresponding to the modes from the MMI_VWHB iterator.
+(define_mode_attr mmi_suffix [(V4SI "w") (V8HI "h") (V16QI "b")])
+
+;; Expander to legitimize moves involving values of vector modes.
+(define_expand "mov<mode>"
+  [(set (match_operand:MMI_VWHB 0)
+	(match_operand:MMI_VWHB 1))]
+  "TARGET_MIPS5900"
+{
+  if (mips_legitimize_move (<MODE>mode, operands[0], operands[1]))
+    DONE;
+})
+
+;; Handle legitimized moves between values of vector modes.
+(define_insn "mov<mode>_internal"
+  [(set (match_operand:MMI_VWHB 0 "nonimmediate_operand" "=d, m,  d")
+	(match_operand:MMI_VWHB 1 "move_operand"             "dYG,dYG,m"))]
+  "TARGET_MIPS5900"
+  { return mips_output_move (operands[0], operands[1]); }
+  [(set_attr "move_type" "move,store,load")])
+
+;; MIN and MAX
+(define_insn "sminsf3"
+  [(set (match_operand:SF 0 "register_operand" "=f")
+	(smin:SF (match_operand:SF 1 "register_operand" "f")
+		 (match_operand:SF 2 "register_operand" "f")))]
+  "TARGET_MIPS5900"
+  "min.s\t%0,%1,%2"
+  [(set_attr "type" "fadd")])
+
+(define_insn "smaxsf3"
+  [(set (match_operand:SF 0 "register_operand" "=f")
+	(smax:SF (match_operand:SF 1 "register_operand" "f")
+		 (match_operand:SF 2 "register_operand" "f")))]
+  "TARGET_MIPS5900"
+  "max.s\t%0,%1,%2"
+  [(set_attr "type" "fadd")
+   (set_attr "mode" "SF")])
+
+;; Logical MMI
+(define_insn "ior<mode>3"
+  [(set (match_operand:MMI_VWHB 0 "register_operand" "=d")
+	(ior:MMI_VWHB (match_operand:MMI_VWHB 1 "register_operand" "d")
+		    (match_operand:MMI_VWHB 2 "register_operand" "d")))]
+  "TARGET_MIPS5900"
+  "por\t%0,%1,%2"
+  [(set_attr "type" "mmi")])
+
+(define_insn "xor<mode>3"
+  [(set (match_operand:MMI_VWHB 0 "register_operand" "=d")
+	(xor:MMI_VWHB (match_operand:MMI_VWHB 1 "register_operand" "d")
+		    (match_operand:MMI_VWHB 2 "register_operand" "d")))]
+  "TARGET_MIPS5900"
+  "pxor\t%0,%1,%2"
+  [(set_attr "type" "mmi")])
+
+(define_insn "nor<mode>3"
+  [(set (match_operand:MMI_VWHB 0 "register_operand" "=d")
+	(and:MMI_VWHB (not:MMI_VWHB (match_operand:MMI_VWHB 1 "register_operand" "d"))
+		 (not:MMI_VWHB (match_operand:MMI_VWHB 2 "register_operand" "d"))))]
+  "TARGET_MIPS5900"
+  "pnor\t%0,%1,%2"
+  [(set_attr "type" "mmi")])
+
+(define_insn "and<mode>3"
+  [(set (match_operand:MMI_VWHB 0 "register_operand" "=d")
+	(and:MMI_VWHB (match_operand:MMI_VWHB 1 "register_operand" "d")
+		    (match_operand:MMI_VWHB 2 "register_operand" "d")))]
+  "TARGET_MIPS5900"
+  "pand\t%0,%1,%2"
+  [(set_attr "type" "mmi")])
+
+;; Arithmetic MMI
+(define_insn "add<mode>3"
+  [(set (match_operand:MMI_VWHB 0 "register_operand" "=d")
+        (plus:MMI_VWHB (match_operand:MMI_VWHB 1 "register_operand" "d")
+		       (match_operand:MMI_VWHB 2 "register_operand" "d")))]
+  "TARGET_MIPS5900"
+  "padd<mmi_suffix>\t%0,%1,%2"
+  [(set_attr "type"	"mmi")])
+
+(define_insn "sub<mode>3"
+  [(set (match_operand:MMI_VWHB 0 "register_operand" "=d")
+        (minus:MMI_VWHB (match_operand:MMI_VWHB 1 "register_operand" "d")
+		        (match_operand:MMI_VWHB 2 "register_operand" "d")))]
+  "TARGET_MIPS5900"
+  "psub<mmi_suffix>\t%0,%1,%2"
+  [(set_attr "type"	"mmi")])
+
+;;  Arithmetic MMI - signed saturation
+(define_insn "ssadd<mode>3"
+  [(set (match_operand:MMI_VWHB 0 "register_operand" "=d")
+        (ss_plus:MMI_VWHB (match_operand:MMI_VWHB 1 "register_operand" "d")
+		          (match_operand:MMI_VWHB 2 "register_operand" "d")))]
+  "TARGET_MIPS5900"
+  "padds<mmi_suffix>\t%0,%1,%2"
+  [(set_attr "type"	"mmi")])
+
+(define_insn "sssub<mode>3"
+  [(set (match_operand:MMI_VWHB 0 "register_operand" "=d")
+        (ss_minus:MMI_VWHB (match_operand:MMI_VWHB 1 "register_operand" "d")
+		           (match_operand:MMI_VWHB 2 "register_operand" "d")))]
+  "TARGET_MIPS5900"
+  "psubs<mmi_suffix>\t%0,%1,%2"
+  [(set_attr "type"	"mmi")])
+
+;;  Arithmetic MMI - unsigned saturation
+(define_insn "usadd<mode>3"
+  [(set (match_operand:MMI_VWHB 0 "register_operand" "=d")
+        (us_plus:MMI_VWHB (match_operand:MMI_VWHB 1 "register_operand" "d")
+		          (match_operand:MMI_VWHB 2 "register_operand" "d")))]
+  "TARGET_MIPS5900"
+  "paddu<mmi_suffix>\t%0,%1,%2"
+  [(set_attr "type"	"mmi")])
+
+(define_insn "ussub<mode>3"
+  [(set (match_operand:MMI_VWHB 0 "register_operand" "=d")
+        (us_minus:MMI_VWHB (match_operand:MMI_VWHB 1 "register_operand" "d")
+		           (match_operand:MMI_VWHB 2 "register_operand" "d")))]
+  "TARGET_MIPS5900"
+  "psubu<mmi_suffix>\t%0,%1,%2"
+  [(set_attr "type"	"mmi")])
diff -rupNb gcc-5.3.0-libgcc/gcc/config/mips/constraints.md gcc-5.3.0-ps2/gcc/config/mips/constraints.md
--- gcc-5.3.0-libgcc/gcc/config/mips/constraints.md	2015-01-15 06:08:37.000000000 +0800
+++ gcc-5.3.0-ps2/gcc/config/mips/constraints.md	2016-03-27 18:06:09.000000000 +0800
@@ -36,10 +36,18 @@
   "The @code{lo} register.  Use this register to store values that are
    no bigger than a word.")
 
+(define_register_constraint "wl" "TARGET_BIG_ENDIAN ? MD1_1_REG : MD1_0_REG"
+  "The @code{lo1} register.  Use this register to store values that are
+   no bigger than a word.")
+
 (define_register_constraint "x" "MD_REGS"
   "The concatenated @code{hi} and @code{lo} registers.  Use this register
    to store doubleword values.")
 
+(define_register_constraint "wr" "MD1_REGS"
+  "The concatenated @code{hi1} and @code{lo1} registers.  Use this register
+   to store doubleword values.")
+
 (define_register_constraint "b" "ALL_REGS"
   "@internal")
 
diff -rupNb gcc-5.3.0-libgcc/gcc/config/mips/mips.c gcc-5.3.0-ps2/gcc/config/mips/mips.c
--- gcc-5.3.0-libgcc/gcc/config/mips/mips.c	2015-08-05 19:20:59.000000000 +0800
+++ gcc-5.3.0-ps2/gcc/config/mips/mips.c	2016-03-27 18:08:32.000000000 +0800
@@ -734,7 +734,8 @@ const enum reg_class mips_regno_to_class
   COP3_REGS,	COP3_REGS,	COP3_REGS,	COP3_REGS,
   DSP_ACC_REGS,	DSP_ACC_REGS,	DSP_ACC_REGS,	DSP_ACC_REGS,
   DSP_ACC_REGS,	DSP_ACC_REGS,	ALL_REGS,	ALL_REGS,
-  ALL_REGS,	ALL_REGS,	ALL_REGS,	ALL_REGS
+  ALL_REGS,	ALL_REGS,	ALL_REGS,	ALL_REGS,
+  MD1_0_REG,	MD1_1_REG
 };
 
 /* The value of TARGET_ATTRIBUTE_TABLE.  */
@@ -4536,6 +4537,24 @@ mips_split_move_p (rtx dest, rtx src, en
 	return false;
     }
 
+  /* The R5900 has special quad-word loads and stores, and 128-bit GPRs.  */
+  if (TARGET_MIPS5900)
+    {
+      if ((   (GET_MODE (dest) == V4SImode)
+	      || (GET_MODE (dest) == V8HImode)
+	      || (GET_MODE (dest) == V16QImode))
+		  && (  (REG_P (src) && GP_REG_P (REGNO (src)) && MEM_P (dest))
+		     || (REG_P (dest) && GP_REG_P (REGNO (dest)) && MEM_P (src))))
+	return false;
+
+      if ((REG_P (src) && REG_P (dest) &&
+		   GP_REG_P (REGNO (src)) && GP_REG_P (REGNO (dest)))
+	      && ((GET_MODE (dest) == V4SImode)
+	       || (GET_MODE (dest) == V8HImode)
+	       || (GET_MODE (dest) == V16QImode)))
+	return false;
+    }
+
   /* Otherwise split all multiword moves.  */
   return size > UNITS_PER_WORD;
 }
@@ -4678,6 +4697,9 @@ mips_output_move (rtx dest, rtx src)
 	  if (REGNO (dest) == LO_REGNUM)
 	    return "mtlo\t%z1";
 
+	  if (REGNO (dest) == LO1_REGNUM)
+	    return "mtlo1\t%z1";
+
 	  if (DSP_ACC_REG_P (REGNO (dest)))
 	    {
 	      static char retval[] = "mt__\t%z1,%q0";
@@ -4705,6 +4727,7 @@ mips_output_move (rtx dest, rtx src)
 	  case 2: return "sh\t%z1,%0";
 	  case 4: return "sw\t%z1,%0";
 	  case 8: return "sd\t%z1,%0";
+	  case 16: return "sq\t%z1,%0";
 	  }
     }
   if (dest_code == REG && GP_REG_P (REGNO (dest)))
@@ -4722,7 +4745,10 @@ mips_output_move (rtx dest, rtx src)
 		return dbl_p ? "dmacc\t%0,%.,%." : "macc\t%0,%.,%.";
 	      return "mflo\t%0";
 	    }
-
+	  if (REGNO (src) == LO1_REGNUM)
+	    {
+	      return "mflo1\t%0";
+	    }
 	  if (DSP_ACC_REG_P (REGNO (src)))
 	    {
 	      static char retval[] = "mf__\t%0,%q1";
@@ -4751,6 +4777,7 @@ mips_output_move (rtx dest, rtx src)
 	  case 2: return "lhu\t%0,%1";
 	  case 4: return "lw\t%0,%1";
 	  case 8: return "ld\t%0,%1";
+	  case 16: return "lq\t%0,%1";
 	  }
 
       if (src_code == CONST_INT)
@@ -5314,6 +5341,9 @@ mips_get_arg_info (struct mips_arg_info
 
   /* Work out the size of the argument.  */
   num_bytes = type ? int_size_in_bytes (type) : GET_MODE_SIZE (mode);
+  if (TARGET_MIPS5900)
+    num_words = (num_bytes + MAX_UNITS_PER_WORD_R5900 - 1) / MAX_UNITS_PER_WORD_R5900;
+  else
   num_words = (num_bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;
 
   /* Decide whether it should go in a floating-point register, assuming
@@ -5718,6 +5748,13 @@ mips_pass_by_reference (cumulative_args_
 	  || mode == DAmode || mode == UDAmode)
 	return 0;
 
+      /* The R5900's registers are large enough to pass arguments in these modes.  */
+      if (TARGET_MIPS5900
+	  && (mode == V4SImode
+	      || mode == V8HImode
+	      || mode == V16QImode))
+	return 0;
+
       size = type ? int_size_in_bytes (type) : GET_MODE_SIZE (mode);
       return size == -1 || size > UNITS_PER_WORD;
     }
@@ -7516,6 +7553,16 @@ mips_block_move_straight (rtx dest, rtx
   machine_mode mode;
   rtx *regs;
 
+  /* The R5900 has quad-word loads and stores, but they will only work 
+     if the data is aligned to at least 128-bit boundaries.  */
+  if (TARGET_MIPS5900
+      && ((MEM_ALIGN (src) >= MAX_BITS_PER_WORD_R5900)
+      && (MEM_ALIGN (dest) >= MAX_BITS_PER_WORD_R5900)))
+    {
+       bits = MAX_BITS_PER_WORD_R5900;
+       mode = mode_for_size (bits, MODE_VECTOR_INT, 0);
+       delta = bits / BITS_PER_UNIT;
+    } else {
   /* Work out how many bits to move at a time.  If both operands have
      half-word alignment, it is usually better to move in half words.
      For instance, lh/lh/sh/sh is usually better than lwl/lwr/swl/swr
@@ -7529,6 +7576,7 @@ mips_block_move_straight (rtx dest, rtx
 
   mode = mode_for_size (bits, MODE_INT, 0);
   delta = bits / BITS_PER_UNIT;
+    }
 
   /* Allocate a buffer for the temporary registers.  */
   regs = XALLOCAVEC (rtx, length / delta);
@@ -8457,6 +8505,7 @@ mips_print_operand_punct_valid_p (unsign
    'Y'	Print mips_fp_conditions[INTVAL (OP)]
    'Z'	Print OP and a comma for ISA_HAS_8CC, otherwise print nothing.
    'q'	Print a DSP accumulator register.
+   'H'	Print the integer pipeline number of the R5900.
    'D'	Print the second part of a double-word register or memory operand.
    'L'	Print the low-order register in a double-word register operand.
    'M'	Print high-order register in a double-word register operand.
@@ -8580,6 +8629,11 @@ mips_print_operand (FILE *file, rtx op,
 	output_operand_lossage ("invalid use of '%%%c'", letter);
       break;
 
+    case 'H':
+      if (code == REG && MD1_REG_P (REGNO (op)))
+	fprintf (file, "1");
+      break;
+
     default:
       switch (code)
 	{
@@ -10117,7 +10171,7 @@ static bool
 mips_interrupt_extra_call_saved_reg_p (unsigned int regno)
 {
   if ((ISA_HAS_HILO || TARGET_DSP)
-      && MD_REG_P (regno))
+      && (MD_REG_P (regno) || MD1_REG_P (regno)))
     return true;
 
   if (TARGET_DSP && DSP_ACC_REG_P (regno))
@@ -10442,12 +10496,19 @@ mips_compute_frame_info (void)
 	  frame->acc_mask |= (1 << 0);
 	}
 
+      /* Check HI1/LO1.  */
+      if (mips_save_reg_p (LO1_REGNUM) || mips_save_reg_p (HI1_REGNUM))
+	{
+	  frame->num_acc++;
+	  frame->acc_mask |= (1 << 1);
+	}
+
       /* Check accumulators 1, 2, 3.  */
       for (i = DSP_ACC_REG_FIRST; i <= DSP_ACC_REG_LAST; i += 2)
 	if (mips_save_reg_p (i) || mips_save_reg_p (i + 1))
 	  {
 	    frame->num_acc++;
-	    frame->acc_mask |= 1 << (((i - DSP_ACC_REG_FIRST) / 2) + 1);
+	    frame->acc_mask |= 1 << (((i - DSP_ACC_REG_FIRST) / 2) + 2);
 	  }
 
       /* All interrupt context functions need space to preserve STATUS.  */
@@ -10792,9 +10853,17 @@ mips_for_each_saved_acc (HOST_WIDE_INT s
       offset -= UNITS_PER_WORD;
     }
 
+  if (BITSET_P (cfun->machine->frame.acc_mask, 1))
+    {
+      mips_save_restore_reg (word_mode, LO1_REGNUM, offset, fn);
+      offset -= UNITS_PER_WORD;
+      mips_save_restore_reg (word_mode, HI1_REGNUM, offset, fn);
+      offset -= UNITS_PER_WORD;
+    }
+
   for (regno = DSP_ACC_REG_FIRST; regno <= DSP_ACC_REG_LAST; regno++)
     if (BITSET_P (cfun->machine->frame.acc_mask,
-		  ((regno - DSP_ACC_REG_FIRST) / 2) + 1))
+		  ((regno - DSP_ACC_REG_FIRST) / 2) + 2))
       {
 	mips_save_restore_reg (word_mode, regno, offset, fn);
 	offset -= UNITS_PER_WORD;
@@ -11051,6 +11120,29 @@ mips_emit_save_slot_move (rtx dest, rtx
 	  mips_emit_move (dest, temp);
 	}
     }
+  else if (regno == HI1_REGNUM)
+    {
+      if (REG_P (dest))
+	{
+	  mips_emit_move (temp, src);
+	  if (TARGET_64BIT)
+	    emit_insn (gen_mthisi_di (gen_rtx_REG (TImode, MD1_REG_FIRST),
+				      temp, gen_rtx_REG (DImode, LO1_REGNUM)));
+	  else
+	    emit_insn (gen_mthisi_di (gen_rtx_REG (DImode, MD1_REG_FIRST),
+				      temp, gen_rtx_REG (SImode, LO1_REGNUM)));
+	}
+      else
+	{
+	  if (TARGET_64BIT)
+	    emit_insn (gen_mfhidi_ti (temp,
+				      gen_rtx_REG (TImode, MD1_REG_FIRST)));
+	  else
+	    emit_insn (gen_mfhisi_di (temp,
+				      gen_rtx_REG (DImode, MD1_REG_FIRST)));
+	  mips_emit_move (dest, temp);
+	}
+    }
   else if (mips_direct_save_slot_move_p (regno, mem, mem == src))
     mips_emit_move (dest, src);
   else
@@ -12091,6 +12183,14 @@ mips_hard_regno_mode_ok_p (unsigned int
   size = GET_MODE_SIZE (mode);
   mclass = GET_MODE_CLASS (mode);
 
+  /* Allow 128-bit vector modes for the R5900.  */
+  if (TARGET_MIPS5900
+    && GP_REG_P (regno)
+    && (mode == V4SImode
+	|| mode == V8HImode
+	|| mode == V16QImode))
+    return true;
+
   if (GP_REG_P (regno) && mode != CCFmode)
     return ((regno - GP_REG_FIRST) & 1) == 0 || size <= UNITS_PER_WORD;
 
@@ -12148,6 +12248,12 @@ mips_hard_regno_mode_ok_p (unsigned int
 	  if (size <= UNITS_PER_WORD * 2)
 	    return regno == (size <= UNITS_PER_WORD ? LO_REGNUM : MD_REG_FIRST);
 	}
+	  else if (MD1_REG_P (regno))
+	{
+	  /* Same as above.  */
+	  if (size <= UNITS_PER_WORD * 2)
+	    return regno == (size <= UNITS_PER_WORD ? LO1_REGNUM : MD1_REG_FIRST);
+	}
       else
 	{
 	  /* DSP accumulators do not have the same restrictions as
@@ -12184,6 +12290,14 @@ mips_hard_regno_nregs (int regno, machin
   if (FP_REG_P (regno))
     return (GET_MODE_SIZE (mode) + UNITS_PER_FPREG - 1) / UNITS_PER_FPREG;
 
+  /* The R5900 supports 128-bit vector modes in its GPRs.  */
+  if (TARGET_MIPS5900
+      && GP_REG_P (regno)
+      && (mode == V4SImode
+	  || mode == V8HImode
+	  || mode == V16QImode))
+    return 1;
+
   /* All other registers are word-sized.  */
   return (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;
 }
@@ -12597,6 +12711,11 @@ mips_vector_mode_supported_p (machine_mo
     case V8QImode:
       return TARGET_LOONGSON_VECTORS;
 
+    case V4SImode:
+    case V8HImode:
+    case V16QImode:
+      return TARGET_MIPS5900;
+
     default:
       return false;
     }
@@ -12824,6 +12943,7 @@ mips_adjust_insn_length (rtx_insn *insn,
 	length += NOP_INSN_LENGTH;
 	break;
 
+      case HAZARD_HILO1:
       case HAZARD_HILO:
 	length += NOP_INSN_LENGTH * 2;
 	break;
@@ -14166,6 +14286,7 @@ AVAIL_NON_MIPS16 (dsp_32, !TARGET_64BIT
 AVAIL_NON_MIPS16 (dsp_64, TARGET_64BIT && TARGET_DSP)
 AVAIL_NON_MIPS16 (dspr2_32, !TARGET_64BIT && TARGET_DSPR2)
 AVAIL_NON_MIPS16 (loongson, TARGET_LOONGSON_VECTORS)
+AVAIL_NON_MIPS16 (mmi, TARGET_MIPS5900)
 AVAIL_NON_MIPS16 (cache, TARGET_CACHE_BUILTIN)
 
 /* Construct a mips_builtin_description from the given arguments.
@@ -14283,6 +14404,14 @@ AVAIL_NON_MIPS16 (cache, TARGET_CACHE_BU
 #define LOONGSON_BUILTIN_SUFFIX(INSN, SUFFIX, FUNCTION_TYPE)		\
   LOONGSON_BUILTIN_ALIAS (INSN, INSN ## _ ## SUFFIX, FUNCTION_TYPE)
 
+/* Define a MMI MIPS_BUILTIN_DIRECT function __builtin_mmi_<INSN>
+   for instruction CODE_FOR_mmi_<INSN>.  FUNCTION_TYPE is a
+   builtin_description field.  */
+#define MMI_DIRECT_BUILTIN(INSN, FUNCTION_TYPE)				\
+  { CODE_FOR_mmi_ ## INSN, MIPS_FP_COND_f,				\
+    "__builtin_mmi_" #INSN, MIPS_BUILTIN_DIRECT, FUNCTION_TYPE,		\
+    mips_builtin_avail_mmi }
+
 #define CODE_FOR_mips_sqrt_ps CODE_FOR_sqrtv2sf2
 #define CODE_FOR_mips_addq_ph CODE_FOR_addv2hi3
 #define CODE_FOR_mips_addu_qb CODE_FOR_addv4qi3
@@ -14323,6 +14452,25 @@ AVAIL_NON_MIPS16 (cache, TARGET_CACHE_BU
 #define CODE_FOR_loongson_psubush CODE_FOR_ussubv4hi3
 #define CODE_FOR_loongson_psubusb CODE_FOR_ussubv8qi3
 
+#define CODE_FOR_mmi_paddb CODE_FOR_addv16qi3
+#define CODE_FOR_mmi_psubb CODE_FOR_subv16qi3
+#define CODE_FOR_mmi_paddh CODE_FOR_addv8hi3
+#define CODE_FOR_mmi_psubh CODE_FOR_subv8hi3
+#define CODE_FOR_mmi_paddw CODE_FOR_addv4si3
+#define CODE_FOR_mmi_psubw CODE_FOR_subv4si3
+#define CODE_FOR_mmi_paddsb CODE_FOR_ssaddv16qi3
+#define CODE_FOR_mmi_psubsb CODE_FOR_sssubv16qi3
+#define CODE_FOR_mmi_paddsh CODE_FOR_ssaddv8hi3
+#define CODE_FOR_mmi_psubsh CODE_FOR_sssubv8hi3
+#define CODE_FOR_mmi_paddsw CODE_FOR_ssaddv4si3
+#define CODE_FOR_mmi_psubsw CODE_FOR_sssubv4si3
+#define CODE_FOR_mmi_paddub CODE_FOR_usaddv16qi3
+#define CODE_FOR_mmi_psubub CODE_FOR_ussubv16qi3
+#define CODE_FOR_mmi_padduh CODE_FOR_usaddv8hi3
+#define CODE_FOR_mmi_psubuh CODE_FOR_ussubv8hi3
+#define CODE_FOR_mmi_padduw CODE_FOR_usaddv4si3
+#define CODE_FOR_mmi_psubuw CODE_FOR_ussubv4si3
+
 static const struct mips_builtin_description mips_builtins[] = {
 #define MIPS_GET_FCSR 0
   DIRECT_BUILTIN (get_fcsr, MIPS_USI_FTYPE_VOID, hard_float),
@@ -14610,6 +14758,26 @@ static const struct mips_builtin_descrip
   LOONGSON_BUILTIN_SUFFIX (punpcklhw, s, MIPS_V4HI_FTYPE_V4HI_V4HI),
   LOONGSON_BUILTIN_SUFFIX (punpcklwd, s, MIPS_V2SI_FTYPE_V2SI_V2SI),
 
+  /* The following are for the MIPS R5900 MMI.  */
+  MMI_DIRECT_BUILTIN (paddb, MIPS_UV16QI_FTYPE_UV16QI_UV16QI),
+  MMI_DIRECT_BUILTIN (psubb, MIPS_UV16QI_FTYPE_UV16QI_UV16QI),
+  MMI_DIRECT_BUILTIN (paddh, MIPS_UV8HI_FTYPE_UV8HI_UV8HI),
+  MMI_DIRECT_BUILTIN (psubh, MIPS_UV8HI_FTYPE_UV8HI_UV8HI),
+  MMI_DIRECT_BUILTIN (paddw, MIPS_UV4SI_FTYPE_UV4SI_UV4SI),
+  MMI_DIRECT_BUILTIN (psubw, MIPS_UV4SI_FTYPE_UV4SI_UV4SI),
+  MMI_DIRECT_BUILTIN (paddsb, MIPS_V16QI_FTYPE_V16QI_V16QI),
+  MMI_DIRECT_BUILTIN (psubsb, MIPS_V16QI_FTYPE_V16QI_V16QI),
+  MMI_DIRECT_BUILTIN (paddsh, MIPS_V8HI_FTYPE_V8HI_V8HI),
+  MMI_DIRECT_BUILTIN (psubsh, MIPS_V8HI_FTYPE_V8HI_V8HI),
+  MMI_DIRECT_BUILTIN (paddsw, MIPS_V4SI_FTYPE_V4SI_V4SI),
+  MMI_DIRECT_BUILTIN (psubsw, MIPS_V4SI_FTYPE_V4SI_V4SI),
+  MMI_DIRECT_BUILTIN (paddub, MIPS_UV16QI_FTYPE_UV16QI_UV16QI),
+  MMI_DIRECT_BUILTIN (psubub, MIPS_UV16QI_FTYPE_UV16QI_UV16QI),
+  MMI_DIRECT_BUILTIN (padduh, MIPS_UV8HI_FTYPE_UV8HI_UV8HI),
+  MMI_DIRECT_BUILTIN (psubuh, MIPS_UV8HI_FTYPE_UV8HI_UV8HI),
+  MMI_DIRECT_BUILTIN (padduw, MIPS_UV4SI_FTYPE_UV4SI_UV4SI),
+  MMI_DIRECT_BUILTIN (psubuw, MIPS_UV4SI_FTYPE_UV4SI_UV4SI),
+
   /* Sundry other built-in functions.  */
   DIRECT_NO_TARGET_BUILTIN (cache, MIPS_VOID_FTYPE_SI_CVPOINTER, cache)
 };
@@ -14672,13 +14840,22 @@ mips_build_cvpointer_type (void)
 #define MIPS_ATYPE_V2SI mips_builtin_vector_type (intSI_type_node, V2SImode)
 #define MIPS_ATYPE_V4QI mips_builtin_vector_type (intQI_type_node, V4QImode)
 #define MIPS_ATYPE_V4HI mips_builtin_vector_type (intHI_type_node, V4HImode)
+#define MIPS_ATYPE_V4SI mips_builtin_vector_type (intSI_type_node, V4SImode)
+#define MIPS_ATYPE_V8HI mips_builtin_vector_type (intHI_type_node, V8HImode)
 #define MIPS_ATYPE_V8QI mips_builtin_vector_type (intQI_type_node, V8QImode)
+#define MIPS_ATYPE_V16QI mips_builtin_vector_type (intQI_type_node, V16QImode)
 #define MIPS_ATYPE_UV2SI					\
   mips_builtin_vector_type (unsigned_intSI_type_node, V2SImode)
 #define MIPS_ATYPE_UV4HI					\
   mips_builtin_vector_type (unsigned_intHI_type_node, V4HImode)
+#define MIPS_ATYPE_UV4SI					\
+  mips_builtin_vector_type (unsigned_intSI_type_node, V4SImode)
+#define MIPS_ATYPE_UV8HI					\
+  mips_builtin_vector_type (unsigned_intHI_type_node, V8HImode)
 #define MIPS_ATYPE_UV8QI					\
   mips_builtin_vector_type (unsigned_intQI_type_node, V8QImode)
+#define MIPS_ATYPE_UV16QI					\
+  mips_builtin_vector_type (unsigned_intQI_type_node, V16QImode)
 
 /* MIPS_FTYPE_ATYPESN takes N MIPS_FTYPES-like type codes and lists
    their associated MIPS_ATYPEs.  */
@@ -16499,11 +16676,12 @@ mips_orphaned_high_part_p (mips_offset_t
    After inserting nops for INSN, update *DELAYED_REG and *HILO_DELAY
    for the next instruction.
 
-   LO_REG is an rtx for the LO register, used in dependence checking.  */
+   LO_REG is an rtx for the LO register, used in dependence checking.
+   LO1_REG and HILO1_DELAY are the equivalents for the 2nd pipeline.  */
 
 static void
-mips_avoid_hazard (rtx_insn *after, rtx_insn *insn, int *hilo_delay,
-		   rtx *delayed_reg, rtx lo_reg)
+mips_avoid_hazard (rtx_insn *after, rtx_insn *insn, int *hilo_delay, int *hilo1_delay,
+		   rtx *delayed_reg, rtx lo_reg, rtx lo1_reg)
 {
   rtx pattern, set;
   int nops, ninsns;
@@ -16527,6 +16705,8 @@ mips_avoid_hazard (rtx_insn *after, rtx_
      clobber hi and lo.  */
   if (*hilo_delay < 2 && reg_set_p (lo_reg, pattern))
     nops = 2 - *hilo_delay;
+  else if (*hilo1_delay < 2 && reg_set_p (lo1_reg, pattern))
+    nops = 2 - *hilo1_delay;
   else if (*delayed_reg != 0 && reg_referenced_p (*delayed_reg, pattern))
     nops = 1;
   else
@@ -16535,11 +16715,13 @@ mips_avoid_hazard (rtx_insn *after, rtx_
   /* Insert the nops between this instruction and the previous one.
      Each new nop takes us further from the last hilo hazard.  */
   *hilo_delay += nops;
+  *hilo1_delay += nops;
   while (nops-- > 0)
     emit_insn_after (gen_hazard_nop (), after);
 
   /* Set up the state for the next instruction.  */
   *hilo_delay += ninsns;
+  *hilo1_delay += ninsns;
   *delayed_reg = 0;
   if (INSN_CODE (insn) >= 0)
     switch (get_attr_hazard (insn))
@@ -16547,6 +16729,10 @@ mips_avoid_hazard (rtx_insn *after, rtx_
       case HAZARD_NONE:
 	break;
 
+      case HAZARD_HILO1:
+	*hilo1_delay = 0;
+	break;
+
       case HAZARD_HILO:
 	*hilo_delay = 0;
 	break;
@@ -16568,8 +16754,8 @@ static void
 mips_reorg_process_insns (void)
 {
   rtx_insn *insn, *last_insn, *subinsn, *next_insn;
-  rtx lo_reg, delayed_reg;
-  int hilo_delay;
+  rtx lo_reg, lo1_reg, delayed_reg;
+  int hilo_delay, hilo1_delay;
 
   /* Force all instructions to be split into their final form.  */
   split_all_insns_noflow ();
@@ -16636,8 +16822,10 @@ mips_reorg_process_insns (void)
 
   last_insn = 0;
   hilo_delay = 2;
+  hilo1_delay = 2;
   delayed_reg = 0;
   lo_reg = gen_rtx_REG (SImode, LO_REGNUM);
+  lo1_reg = gen_rtx_REG (SImode, LO1_REGNUM);
 
   /* Make a second pass over the instructions.  Delete orphaned
      high-part relocations or turn them into NOPs.  Avoid hazards
@@ -16660,8 +16848,8 @@ mips_reorg_process_insns (void)
 			PATTERN (subinsn) = gen_nop ();
 			INSN_CODE (subinsn) = CODE_FOR_nop;
 		      }
-		    mips_avoid_hazard (last_insn, subinsn, &hilo_delay,
-				       &delayed_reg, lo_reg);
+		    mips_avoid_hazard (last_insn, subinsn, &hilo_delay, &hilo1_delay,
+				       &delayed_reg, lo_reg, lo1_reg);
 		  }
 	      last_insn = insn;
 	    }
@@ -16681,8 +16869,8 @@ mips_reorg_process_insns (void)
 		delete_insn (insn);
 	      else
 		{
-		  mips_avoid_hazard (last_insn, insn, &hilo_delay,
-				     &delayed_reg, lo_reg);
+		  mips_avoid_hazard (last_insn, insn, &hilo_delay, &hilo1_delay,
+				     &delayed_reg, lo_reg, lo1_reg);
 		  last_insn = insn;
 		}
 	    }
@@ -17739,6 +17927,8 @@ mips_option_override (void)
   mips_dbx_regno[LO_REGNUM] = MD_DBX_FIRST + 1;
   mips_dwarf_regno[HI_REGNUM] = MD_REG_FIRST + 0;
   mips_dwarf_regno[LO_REGNUM] = MD_REG_FIRST + 1;
+  mips_dwarf_regno[HI1_REGNUM] = MD1_REG_FIRST + 0;
+  mips_dwarf_regno[LO1_REGNUM] = MD1_REG_FIRST + 1;
   for (i = DSP_ACC_REG_FIRST; i <= DSP_ACC_REG_LAST; i += 2)
     {
       mips_dwarf_regno[i + TARGET_LITTLE_ENDIAN] = i;
@@ -17867,8 +18057,16 @@ mips_conditional_register_usage (void)
 			    reg_class_contents[(int) DSP_ACC_REGS]);
 
   if (!ISA_HAS_HILO)
+    {
     AND_COMPL_HARD_REG_SET (accessible_reg_set,
 			    reg_class_contents[(int) MD_REGS]);
+    AND_COMPL_HARD_REG_SET (accessible_reg_set,
+			    reg_class_contents[(int) MD1_REGS]);
+    }
+
+  if (!TARGET_MIPS5900)
+      AND_COMPL_HARD_REG_SET (accessible_reg_set,
+		    reg_class_contents[(int) MD1_REGS]);
 
   if (!TARGET_HARD_FLOAT)
     {
@@ -17927,6 +18125,8 @@ mips_conditional_register_usage (void)
 	 for them) and one-way registers cannot easily be reloaded.  */
       AND_COMPL_HARD_REG_SET (operand_reg_set,
 			      reg_class_contents[(int) MD_REGS]);
+      AND_COMPL_HARD_REG_SET (operand_reg_set,
+			      reg_class_contents[(int) MD1_REGS]);
     }
   /* $f20-$f23 are call-clobbered for n64.  */
   if (mips_abi == ABI_64)
@@ -17952,6 +18152,7 @@ mips_conditional_register_usage (void)
       unsigned int regno;
 
       mips_swap_registers (MD_REG_FIRST);
+      mips_swap_registers (MD1_REG_FIRST);
       for (regno = DSP_ACC_REG_FIRST; regno <= DSP_ACC_REG_LAST; regno += 2)
 	mips_swap_registers (regno);
     }
diff -rupNb gcc-5.3.0-libgcc/gcc/config/mips/mips-ftypes.def gcc-5.3.0-ps2/gcc/config/mips/mips-ftypes.def
--- gcc-5.3.0-libgcc/gcc/config/mips/mips-ftypes.def	2015-01-05 20:33:28.000000000 +0800
+++ gcc-5.3.0-ps2/gcc/config/mips/mips-ftypes.def	2016-02-26 14:58:32.000000000 +0800
@@ -127,3 +127,10 @@ DEF_MIPS_FTYPE (2, (VOID, SI, SI))
 DEF_MIPS_FTYPE (1, (VOID, USI))
 DEF_MIPS_FTYPE (2, (VOID, V2HI, V2HI))
 DEF_MIPS_FTYPE (2, (VOID, V4QI, V4QI))
+
+DEF_MIPS_FTYPE (2, (UV16QI, UV16QI, UV16QI))
+DEF_MIPS_FTYPE (2, (UV8HI, UV8HI, UV8HI))
+DEF_MIPS_FTYPE (2, (UV4SI, UV4SI, UV4SI))
+DEF_MIPS_FTYPE (2, (V16QI, V16QI, V16QI))
+DEF_MIPS_FTYPE (2, (V8HI, V8HI, V8HI))
+DEF_MIPS_FTYPE (2, (V4SI, V4SI, V4SI))
diff -rupNb gcc-5.3.0-libgcc/gcc/config/mips/mips.h gcc-5.3.0-ps2/gcc/config/mips/mips.h
--- gcc-5.3.0-libgcc/gcc/config/mips/mips.h	2015-01-20 07:05:41.000000000 +0800
+++ gcc-5.3.0-ps2/gcc/config/mips/mips.h	2016-03-27 18:07:40.000000000 +0800
@@ -267,6 +267,7 @@ struct mips_cpu_info {
 #define TUNE_MIPS5000               (mips_tune == PROCESSOR_R5000)
 #define TUNE_MIPS5400               (mips_tune == PROCESSOR_R5400)
 #define TUNE_MIPS5500               (mips_tune == PROCESSOR_R5500)
+#define TUNE_MIPS5900               (mips_tune == PROCESSOR_R5900)
 #define TUNE_MIPS6000               (mips_tune == PROCESSOR_R6000)
 #define TUNE_MIPS7000               (mips_tune == PROCESSOR_R7000)
 #define TUNE_MIPS9000               (mips_tune == PROCESSOR_R9000)
@@ -319,7 +320,8 @@ struct mips_cpu_info {
 				     || TUNE_MIPS4120		\
 				     || TUNE_MIPS4130		\
 				     || TUNE_24K		\
-				     || TUNE_P5600)
+				     || TUNE_P5600		\
+				     || TUNE_MIPS5900)
 
 #define TARGET_OLDABI		    (mips_abi == ABI_32 || mips_abi == ABI_O64)
 #define TARGET_NEWABI		    (mips_abi == ABI_N32 || mips_abi == ABI_64)
@@ -992,8 +994,9 @@ struct mips_cpu_info {
 				 && !TARGET_MIPS16)
 
 /* ISA has integer multiply-accumulate instructions, madd and msub.  */
-#define ISA_HAS_MADD_MSUB	(mips_isa_rev >= 1			\
-				 && mips_isa_rev <= 5)
+#define ISA_HAS_MADD_MSUB	((mips_isa_rev >= 1			\
+				 && mips_isa_rev <= 5)	\
+				 || TARGET_MIPS5900)
 
 /* Integer multiply-accumulate instructions should be generated.  */
 #define GENERATE_MADD_MSUB	(TARGET_IMADD && !TARGET_MIPS16)
@@ -1029,7 +1032,9 @@ struct mips_cpu_info {
 				       || (MODE) == DFmode)		\
 				      && (mips_isa_rev >= 6))		\
 				  || (TARGET_SB1			\
-				      && (MODE) == V2SFmode))		\
+				      && (MODE) == V2SFmode)		\
+				  || (TARGET_MIPS5900			\
+					  && (MODE) == SFmode))		\
 				 && !TARGET_MIPS16)
 
 #define ISA_HAS_LWL_LWR		(mips_isa_rev <= 5 && !TARGET_MIPS16)
@@ -1451,6 +1456,10 @@ FP_ASM_SPEC "\
 #define MIN_UNITS_PER_WORD 4
 #endif
 
+/* The R5900 has 128-bit registers.  */
+#define MAX_UNITS_PER_WORD_R5900 16
+#define MAX_BITS_PER_WORD_R5900 128
+
 /* For MIPS, width of a floating point register.  */
 #define UNITS_PER_FPREG (TARGET_FLOAT64 ? 8 : 4)
 
@@ -1649,9 +1658,10 @@ FP_ASM_SPEC "\
 	- CPRESTORE_SLOT_REGNUM
    - 2 dummy entries that were used at various times in the past.
    - 6 DSP accumulator registers (3 hi-lo pairs) for MIPS DSP ASE
-   - 6 DSP control registers  */
+   - 6 DSP control registers
+   - 2 accumulator registers for the R5900's second pipeline (hi1 and lo1)   */
 
-#define FIRST_PSEUDO_REGISTER 188
+#define FIRST_PSEUDO_REGISTER 190
 
 /* By default, fix the kernel registers ($26 and $27), the global
    pointer ($28) and the stack pointer ($29).  This can change
@@ -1679,8 +1689,9 @@ FP_ASM_SPEC "\
   /* COP3 registers */							\
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,			\
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,			\
-  /* 6 DSP accumulator registers & 6 control registers */		\
-  0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1					\
+  /* 6 DSP accumulator registers & 6 control registers,			\
+     and hi1/lo1 for the R5900  */					\
+  0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0				\
 }
 
 
@@ -1711,8 +1722,9 @@ FP_ASM_SPEC "\
   /* COP3 registers */							\
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,			\
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,			\
-  /* 6 DSP accumulator registers & 6 control registers */		\
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1					\
+  /* 6 DSP accumulator registers & 6 control registers,			\
+     and hi1/lo1 for the R5900  */					\
+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1				\
 }
 
 
@@ -1736,8 +1748,9 @@ FP_ASM_SPEC "\
   /* COP3 registers */							\
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,			\
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,			\
-  /* 6 DSP accumulator registers & 6 control registers */		\
-  1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0					\
+  /* 6 DSP accumulator registers & 6 control registers,			\
+     and hi1/lo1 for the R5900  */					\
+  1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1				\
 }
 
 /* Internal macros to classify a register number as to whether it's a
@@ -1799,9 +1812,15 @@ FP_ASM_SPEC "\
 #define DSP_ACC_REG_LAST 181
 #define DSP_ACC_REG_NUM (DSP_ACC_REG_LAST - DSP_ACC_REG_FIRST + 1)
 
+#define MD1_REG_FIRST 188
+#define MD1_REG_LAST  189
+#define MD1_REG_NUM   (MD1_REG_LAST - MD1_REG_FIRST + 1)
+
 #define AT_REGNUM	(GP_REG_FIRST + 1)
 #define HI_REGNUM	(TARGET_BIG_ENDIAN ? MD_REG_FIRST : MD_REG_FIRST + 1)
 #define LO_REGNUM	(TARGET_BIG_ENDIAN ? MD_REG_FIRST + 1 : MD_REG_FIRST)
+#define HI1_REGNUM	(TARGET_BIG_ENDIAN ? MD1_REG_FIRST : MD1_REG_FIRST + 1)
+#define LO1_REGNUM	(TARGET_BIG_ENDIAN ? MD1_REG_FIRST + 1 : MD1_REG_FIRST)
 
 /* A few bitfield locations for the coprocessor registers.  */
 /* Request Interrupt Priority Level is from bit 10 to bit 15 of
@@ -1844,7 +1863,10 @@ FP_ASM_SPEC "\
   ((unsigned int) ((int) (REGNO) - DSP_ACC_REG_FIRST) < DSP_ACC_REG_NUM)
 /* Test if REGNO is hi, lo, or one of the 6 new DSP accumulators.  */
 #define ACC_REG_P(REGNO) \
-  (MD_REG_P (REGNO) || DSP_ACC_REG_P (REGNO))
+  (MD_REG_P (REGNO) || MD1_REG_P (REGNO) || DSP_ACC_REG_P (REGNO))
+/* Test if REGNO is HI1 or LO1 registers of the 2nd pipeline to the R5900.  */
+#define MD1_REG_P(REGNO) \
+  ((unsigned int) ((int) (REGNO) - MD1_REG_FIRST) < MD1_REG_NUM)
 
 #define FP_REG_RTX_P(X) (REG_P (X) && FP_REG_P (REGNO (X)))
 
@@ -1872,10 +1894,14 @@ FP_ASM_SPEC "\
   mips_hard_regno_caller_save_mode (REGNO, NREGS, MODE)
 
 /* Odd-numbered single-precision registers are not considered callee-saved
-   for o32 FPXX as they will be clobbered when run on an FR=1 FPU.  */
+   for o32 FPXX as they will be clobbered when run on an FR=1 FPU.
+
+   The R5900 has 128-bit registers. The upper 64-bits of each GPR
+   is used for MMI, but is not callee-saved.  */
 #define HARD_REGNO_CALL_PART_CLOBBERED(REGNO, MODE)			\
-  (TARGET_FLOATXX && hard_regno_nregs[REGNO][MODE] == 1			\
-   && FP_REG_P (REGNO) && ((REGNO) & 1))
+  ((TARGET_FLOATXX && hard_regno_nregs[REGNO][MODE] == 1			\
+    && FP_REG_P (REGNO) && ((REGNO) & 1))					\
+   || (TARGET_MIPS5900 && GET_MODE_SIZE (MODE) >= UNITS_PER_WORD))
 
 #define MODES_TIEABLE_P mips_modes_tieable_p
 
@@ -1996,6 +2022,9 @@ enum reg_class
   MD0_REG,			/* first multiply/divide register */
   MD1_REG,			/* second multiply/divide register */
   MD_REGS,			/* multiply/divide registers (hi/lo) */
+  MD1_0_REG,			/* 2nd pipeline, first multiply/divide register */
+  MD1_1_REG,			/* 2nd pipeline, second multiply/divide register */
+  MD1_REGS,			/* 2nd pipeline, multiply/divide registers (hi/lo) */
   COP0_REGS,			/* generic coprocessor classes */
   COP2_REGS,
   COP3_REGS,
@@ -2006,6 +2035,9 @@ enum reg_class
   GR_AND_MD0_REGS,		/* union classes */
   GR_AND_MD1_REGS,
   GR_AND_MD_REGS,
+  GR_AND_MD0_1_REGS,
+  GR_AND_MD1_1_REGS,
+  GR_AND_MD_1_REGS,
   GR_AND_ACC_REGS,
   ALL_REGS,			/* all registers */
   LIM_REG_CLASSES		/* max value + 1 */
@@ -2036,6 +2068,9 @@ enum reg_class
   "MD0_REG",								\
   "MD1_REG",								\
   "MD_REGS",								\
+  "MD1_0_REG",								\
+  "MD1_1_REG",								\
+  "MD1_REGS",								\
   /* coprocessor registers */						\
   "COP0_REGS",								\
   "COP2_REGS",								\
@@ -2047,6 +2082,9 @@ enum reg_class
   "GR_AND_MD0_REGS",							\
   "GR_AND_MD1_REGS",							\
   "GR_AND_MD_REGS",							\
+  "GR_AND_MD0_1_REGS",							\
+  "GR_AND_MD1_1_REGS",							\
+  "GR_AND_MD_1_REGS",							\
   "GR_AND_ACC_REGS",							\
   "ALL_REGS"								\
 }
@@ -2079,18 +2117,24 @@ enum reg_class
   { 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000000, 0x00000000 },	/* MD0_REG */		\
   { 0x00000000, 0x00000000, 0x00000002, 0x00000000, 0x00000000, 0x00000000 },	/* MD1_REG */		\
   { 0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x00000000, 0x00000000 },	/* MD_REGS */		\
+  { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x10000000 },	/* MD1_0_REG */		\
+  { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x20000000 },	/* MD1_1_REG */		\
+  { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x30000000 },	/* MD1_REGS */		\
   { 0x00000000, 0x00000000, 0xffff0000, 0x0000ffff, 0x00000000, 0x00000000 },   /* COP0_REGS */		\
   { 0x00000000, 0x00000000, 0x00000000, 0xffff0000, 0x0000ffff, 0x00000000 },   /* COP2_REGS */		\
   { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xffff0000, 0x0000ffff },   /* COP3_REGS */		\
   { 0x00000000, 0x00000000, 0x000007f8, 0x00000000, 0x00000000, 0x00000000 },	/* ST_REGS */		\
   { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x003f0000 },	/* DSP_ACC_REGS */	\
-  { 0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x00000000, 0x003f0000 },	/* ACC_REGS */		\
+  { 0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x00000000, 0x303f0000 },	/* ACC_REGS */		\
   { 0x00000000, 0x00000000, 0x00006000, 0x00000000, 0x00000000, 0x00000000 },	/* FRAME_REGS */	\
   { 0xffffffff, 0x00000000, 0x00000001, 0x00000000, 0x00000000, 0x00000000 },	/* GR_AND_MD0_REGS */	\
   { 0xffffffff, 0x00000000, 0x00000002, 0x00000000, 0x00000000, 0x00000000 },	/* GR_AND_MD1_REGS */	\
   { 0xffffffff, 0x00000000, 0x00000003, 0x00000000, 0x00000000, 0x00000000 },	/* GR_AND_MD_REGS */	\
-  { 0xffffffff, 0x00000000, 0x00000003, 0x00000000, 0x00000000, 0x003f0000 },	/* GR_AND_ACC_REGS */	\
-  { 0xffffffff, 0xffffffff, 0xffff67ff, 0xffffffff, 0xffffffff, 0x0fffffff }	/* ALL_REGS */		\
+  { 0xffffffff, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x10000000 },	/* GR_AND_MD0_1_REGS */	\
+  { 0xffffffff, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x20000000 },	/* GR_AND_MD1_1_REGS */	\
+  { 0xffffffff, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x30000000 },	/* GR_AND_MD_1_REGS */	\
+  { 0xffffffff, 0x00000000, 0x00000003, 0x00000000, 0x00000000, 0x303f0000 },	/* GR_AND_ACC_REGS */	\
+  { 0xffffffff, 0xffffffff, 0xffff67ff, 0xffffffff, 0xffffffff, 0x3fffffff }	/* ALL_REGS */		\
 }
 
 
@@ -2126,7 +2170,7 @@ enum reg_class
      point of definition.  It's also needed if we're to take advantage	\
      of the extra accumulators available with -mdspr2.  In some cases,	\
      it can also help to reduce register pressure.  */			\
-  64, 65,176,177,178,179,180,181,					\
+  64, 65,176,177,178,179,180,181, 188, 189,				\
   /* Call-clobbered GPRs.  */						\
   1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,		\
   24, 25, 31,								\
@@ -2720,7 +2764,7 @@ typedef struct mips_args {
   "$c3r16","$c3r17","$c3r18","$c3r19","$c3r20","$c3r21","$c3r22","$c3r23", \
   "$c3r24","$c3r25","$c3r26","$c3r27","$c3r28","$c3r29","$c3r30","$c3r31", \
   "$ac1hi","$ac1lo","$ac2hi","$ac2lo","$ac3hi","$ac3lo","$dsp_po","$dsp_sc", \
-  "$dsp_ca","$dsp_ou","$dsp_cc","$dsp_ef" }
+  "$dsp_ca","$dsp_ou","$dsp_cc","$dsp_ef", "hi1", "lo1" }
 
 /* List the "software" names for each register.  Also list the numerical
    names for $fp and $sp.  */
diff -rupNb gcc-5.3.0-libgcc/gcc/config/mips/mips.md gcc-5.3.0-ps2/gcc/config/mips/mips.md
--- gcc-5.3.0-libgcc/gcc/config/mips/mips.md	2015-03-03 08:07:19.000000000 +0800
+++ gcc-5.3.0-ps2/gcc/config/mips/mips.md	2016-02-26 14:58:32.000000000 +0800
@@ -222,7 +222,7 @@
 (define_attr "move_type"
   "unknown,load,fpload,store,fpstore,mtc,mfc,mtlo,mflo,imul,move,fmove,
    const,constN,signext,ext_ins,logical,arith,sll0,andi,loadpool,
-   shift_shift"
+   shift_shift,mtlo1,mflo1"
   (const_string "unknown"))
 
 (define_attr "alu_type" "unknown,add,sub,not,nor,and,or,xor"
@@ -315,6 +315,10 @@
 ;; mtlo		transfer to a lo register
 ;; mfhi		transfer from a hi register
 ;; mflo		transfer from a lo register
+;; mthi1	transfer to a hi1 register
+;; mtlo1	transfer to a lo1 register
+;; mfhi1	transfer from a hi1 register
+;; mflo1	transfer from a lo1 register
 ;; const	load constant
 ;; arith	integer arithmetic instructions
 ;; logical      integer logical instructions
@@ -359,13 +363,14 @@
 ;; nop		no operation
 ;; ghost	an instruction that produces no real code
 ;; multimem	microMIPS multiword load and store
+;; mmi		R5900 Multimedia Instruction
 (define_attr "type"
   "unknown,branch,jump,call,load,fpload,fpidxload,store,fpstore,fpidxstore,
    prefetch,prefetchx,condmove,mtc,mfc,mthi,mtlo,mfhi,mflo,const,arith,logical,
    shift,slt,signext,clz,pop,trap,imul,imul3,imul3nc,imadd,idiv,idiv3,move,
    fmove,fadd,fmul,fmadd,fdiv,frdiv,frdiv1,frdiv2,fabs,fneg,fcmp,fcvt,fsqrt,
    frsqrt,frsqrt1,frsqrt2,dspmac,dspmacsat,accext,accmod,dspalu,dspalusat,
-   multi,atomic,syncloop,nop,ghost,multimem"
+   multi,atomic,syncloop,nop,ghost,multimem,mthi1,mtlo1,mfhi1,mflo1,mmi"
   (cond [(eq_attr "jal" "!unset") (const_string "call")
 	 (eq_attr "got" "load") (const_string "load")
 
@@ -384,6 +389,8 @@
 	 (eq_attr "move_type" "mfc") (const_string "mfc")
 	 (eq_attr "move_type" "mtlo") (const_string "mtlo")
 	 (eq_attr "move_type" "mflo") (const_string "mflo")
+	 (eq_attr "move_type" "mtlo1") (const_string "mtlo1")
+	 (eq_attr "move_type" "mflo1") (const_string "mflo1")
 
 	 ;; These types of move are always single insns.
 	 (eq_attr "move_type" "imul") (const_string "imul")
@@ -473,7 +480,7 @@
 	 ;; Check for doubleword moves that are decomposed into two
 	 ;; instructions.  The individual instructions are unextended
 	 ;; MIPS16 ones.
-	 (and (eq_attr "move_type" "mtc,mfc,mtlo,mflo,move")
+	 (and (eq_attr "move_type" "mtc,mfc,mtlo,mflo,move,mtlo1,mflo1")
 	      (eq_attr "dword_mode" "yes"))
 	 (const_int 2)
 
@@ -694,7 +701,7 @@
 ;; DELAY means that the next instruction cannot read the result
 ;; of this one.  HILO means that the next two instructions cannot
 ;; write to HI or LO.
-(define_attr "hazard" "none,delay,hilo"
+(define_attr "hazard" "none,delay,hilo,hilo1"
   (cond [(and (eq_attr "type" "load,fpload,fpidxload")
 	      (match_test "ISA_HAS_LOAD_DELAY"))
 	 (const_string "delay")
@@ -714,7 +721,11 @@
 
 	 (and (eq_attr "type" "mfhi,mflo")
 	      (not (match_test "ISA_HAS_HILO_INTERLOCKS")))
-	 (const_string "hilo")]
+	 (const_string "hilo")
+
+	 (and (eq_attr "type" "mfhi1,mflo1")
+	      (not (match_test "ISA_HAS_HILO_INTERLOCKS")))
+	 (const_string "hilo1")]
 	(const_string "none")))
 
 ;; Can the instruction be put into a delay slot?
@@ -739,6 +750,12 @@
 		(const_string "yes")
 		(const_string "no")))
 
+;; True if an instruction uses a R5900 integer multiplication/division pipeline.
+(define_attr "is_imuldiv_insn" "no,yes"
+  (if_then_else (eq_attr "type" "imul,imul3,imadd,idiv")
+		(const_string "yes")
+		(const_string "no")))
+
 ;; Describe a user's asm statement.
 (define_asm_attributes
   [(set_attr "type" "multi")
@@ -1095,6 +1112,7 @@
 (include "5000.md")
 (include "5400.md")
 (include "5500.md")
+(include "5900.md")
 (include "6000.md")
 (include "7000.md")
 (include "9000.md")
@@ -1530,7 +1548,12 @@
     emit_insn (gen_mul<mode>3_mul3_nohilo (operands[0], operands[1],
 					   operands[2]));
   else if (ISA_HAS_<D>MUL3)
+    {
+	  if (TARGET_MIPS5900)
+	    emit_insn (gen_mul<mode>3_mul3_r5900 (operands[0], operands[1], operands[2]));
+	  else
     emit_insn (gen_mul<mode>3_mul3 (operands[0], operands[1], operands[2]));
+	}
   else if (TARGET_MIPS16)
     {
       lo = gen_rtx_REG (<MODE>mode, LO_REGNUM);
@@ -1566,17 +1589,34 @@
 	(mult:GPR (match_operand:GPR 1 "register_operand" "d,d")
 		  (match_operand:GPR 2 "register_operand" "d,d")))
    (clobber (match_scratch:GPR 3 "=l,X"))]
-  "ISA_HAS_<D>MUL3"
+  "ISA_HAS_<D>MUL3 && !TARGET_MIPS5900"
 {
   if (which_alternative == 1)
     return "<d>mult\t%1,%2";
-  if (<MODE>mode == SImode && (TARGET_MIPS3900 || TARGET_MIPS5900))
+  if (<MODE>mode == SImode && TARGET_MIPS3900)
     return "mult\t%0,%1,%2";
   return "<d>mul\t%0,%1,%2";
 }
   [(set_attr "type" "imul3,imul")
    (set_attr "mode" "<MODE>")])
 
+(define_insn "mul<mode>3_mul3_r5900"
+  [(set (match_operand:GPR 0 "register_operand" "=d,lwl")
+	(mult:GPR (match_operand:GPR 1 "register_operand" "d,d")
+		  (match_operand:GPR 2 "register_operand" "d,d")))
+   (clobber (match_scratch:GPR 3 "=lwl,X"))]
+  "ISA_HAS_<D>MUL3 && TARGET_MIPS5900"
+{
+  if (which_alternative == 1)
+    return "<d>mult%H0\t%1,%2";
+
+  if (<MODE>mode == SImode)
+      return "mult%H3\t%0,%1,%2";
+  return "<d>mul%H3\t%0,%1,%2";
+}
+  [(set_attr "type" "imul3,imul")
+   (set_attr "mode" "<MODE>")])
+
 ;; If a register gets allocated to LO, and we spill to memory, the reload
 ;; will include a move from LO to a GPR.  Merge it into the multiplication
 ;; if it can set the GPR directly.
@@ -1601,13 +1641,21 @@
         (clobber (match_dup 0))])])
 
 (define_insn "mul<mode>3_internal"
-  [(set (match_operand:GPR 0 "muldiv_target_operand" "=l")
-	(mult:GPR (match_operand:GPR 1 "register_operand" "d")
-		  (match_operand:GPR 2 "register_operand" "d")))]
+  [(set (match_operand:GPR 0 "muldiv_target_operand" "=l,lwl")
+	(mult:GPR (match_operand:GPR 1 "register_operand" "d,d")
+		  (match_operand:GPR 2 "register_operand" "d,d")))]
   "ISA_HAS_<D>MULT && !TARGET_FIX_R4000"
-  "<d>mult\t%1,%2"
-  [(set_attr "type" "imul")
-   (set_attr "mode" "<MODE>")])
+  { return TARGET_MIPS5900 ? "<d>mult%H0\t%1,%2" : "<d>mult\t%1,%2"; }
+  [(set_attr "type" "imul,imul")
+   (set_attr "mode" "<MODE>")
+   (set (attr "enabled")
+        (cond [(and (eq_attr "alternative" "0")
+                    (eq_attr "cpu" "!r5900"))
+                  (const_string "yes")
+               (and (eq_attr "alternative" "1")
+                    (eq_attr "cpu" "r5900"))
+                  (const_string "yes")]
+              (const_string "no")))])
 
 (define_insn "mul<mode>3_r4000"
   [(set (match_operand:GPR 0 "register_operand" "=d")
@@ -1675,7 +1723,7 @@
 		 (match_operand:SI 3 "register_operand" "0,0,d")))
    (clobber (match_scratch:SI 4 "=X,X,l"))
    (clobber (match_scratch:SI 5 "=X,X,&d"))]
-  "GENERATE_MADD_MSUB && !TARGET_MIPS16"
+  "GENERATE_MADD_MSUB && !TARGET_MIPS16 && !TARGET_MIPS5900"
   "@
     madd\t%1,%2
     madd\t%1,%2
@@ -1725,6 +1773,34 @@
                   (const_string "yes")]
               (const_string "no")))])
 
+;; The same idea applies here.
+(define_insn "*mul_acc_si_r5900"
+  [(set (match_operand:SI 0 "register_operand" "=l*?*?wl*?*?,lwl,d?")
+	(plus:SI (mult:SI (match_operand:SI 1 "register_operand" "d,d,d")
+			  (match_operand:SI 2 "register_operand" "d,d,d"))
+		 (match_operand:SI 3 "register_operand" "0,0,d")))
+   (clobber (match_scratch:SI 4 "=X,X,lwl"))
+   (clobber (match_scratch:SI 5 "=X,X,&d"))]
+  "GENERATE_MADD_MSUB && TARGET_MIPS5900"
+  "@
+    madd%H0\t%1,%2
+    madd%H0\t%1,%2
+    #"
+  [(set_attr "type"	"imadd")
+   (set_attr "accum_in"	"3")
+   (set_attr "mode"	"SI")
+   (set_attr "insn_count" "1,1,2")
+   (set (attr "enabled")
+        (cond [(and (eq_attr "alternative" "0")
+                    (match_test "!mips_lra_flag"))
+                  (const_string "yes")
+               (and (eq_attr "alternative" "1")
+                    (match_test "mips_lra_flag"))
+                  (const_string "yes")
+               (eq_attr "alternative" "2")
+                  (const_string "yes")]
+              (const_string "no")))])
+
 ;; Split *mul_acc_si if both the source and destination accumulator
 ;; values are GPRs.
 (define_split
@@ -1933,7 +2009,7 @@
                            (match_operand:SI 3 "register_operand" "d,d,d"))))
    (clobber (match_scratch:SI 4 "=X,X,l"))
    (clobber (match_scratch:SI 5 "=X,X,&d"))]
-  "GENERATE_MADD_MSUB"
+  "GENERATE_MADD_MSUB && !TARGET_MIPS5900"
   "@
    msub\t%2,%3
    msub\t%2,%3
@@ -2028,18 +2104,28 @@
 ;; __builtin_mips_mult<u>() functions.  We must always make those functions
 ;; available if !TARGET_64BIT && ISA_HAS_DSP.
 (define_insn "<u>mulsidi3_32bit"
-  [(set (match_operand:DI 0 "muldiv_target_operand" "=ka")
-	(mult:DI (any_extend:DI (match_operand:SI 1 "register_operand" "d"))
-		 (any_extend:DI (match_operand:SI 2 "register_operand" "d"))))]
+  [(set (match_operand:DI 0 "muldiv_target_operand" "=ka,kawr")
+	(mult:DI (any_extend:DI (match_operand:SI 1 "register_operand" "d,d"))
+		 (any_extend:DI (match_operand:SI 2 "register_operand" "d,d"))))]
   "!TARGET_64BIT && (!TARGET_FIX_R4000 || ISA_HAS_DSP) && ISA_HAS_MULT"
 {
   if (ISA_HAS_DSP_MULT)
     return "mult<u>\t%q0,%1,%2";
+  else if(TARGET_MIPS5900)
+    return "mult<u>%H0\t%1,%2";
   else
     return "mult<u>\t%1,%2";
 }
-  [(set_attr "type" "imul")
-   (set_attr "mode" "SI")])
+  [(set_attr "type" "imul,imul")
+   (set_attr "mode" "SI")
+   (set (attr "enabled")
+        (cond [(and (eq_attr "alternative" "0")
+                    (eq_attr "cpu" "!r5900"))
+                  (const_string "yes")
+               (and (eq_attr "alternative" "1")
+                    (eq_attr "cpu" "r5900"))
+                  (const_string "yes")]
+              (const_string "no")))])
 
 (define_insn "<u>mulsidi3_32bit_r4000"
   [(set (match_operand:DI 0 "register_operand" "=d")
@@ -2053,11 +2139,11 @@
    (set_attr "insn_count" "3")])
 
 (define_insn_and_split "<u>mulsidi3_64bit"
-  [(set (match_operand:DI 0 "register_operand" "=d")
-	(mult:DI (any_extend:DI (match_operand:SI 1 "register_operand" "d"))
-		 (any_extend:DI (match_operand:SI 2 "register_operand" "d"))))
-   (clobber (match_scratch:TI 3 "=x"))
-   (clobber (match_scratch:DI 4 "=d"))]
+  [(set (match_operand:DI 0 "register_operand" "=d,d")
+	(mult:DI (any_extend:DI (match_operand:SI 1 "register_operand" "d,d"))
+		 (any_extend:DI (match_operand:SI 2 "register_operand" "d,d"))))
+   (clobber (match_scratch:TI 3 "=x,xwr"))
+   (clobber (match_scratch:DI 4 "=d,d"))]
   "TARGET_64BIT && !TARGET_FIX_R4000 && !ISA_HAS_DMUL3
    && !TARGET_MIPS16 && ISA_HAS_MULT"
   "#"
@@ -2065,15 +2151,23 @@
   [(const_int 0)]
 {
   emit_insn (gen_<u>mulsidi3_64bit_split (operands[0], operands[1],
-					  operands[2], operands[4]));
+					  operands[2], operands[4], operands[3]));
   DONE;
 }
-  [(set_attr "type" "imul")
+  [(set_attr "type" "imul,imul")
    (set_attr "mode" "SI")
    (set (attr "insn_count")
 	(if_then_else (match_test "ISA_HAS_EXT_INS")
 		      (const_int 4)
-		      (const_int 7)))])
+		      (const_int 7)))
+   (set (attr "enabled")
+        (cond [(and (eq_attr "alternative" "0")
+                    (eq_attr "cpu" "!r5900"))
+                  (const_string "yes")
+               (and (eq_attr "alternative" "1")
+                    (eq_attr "cpu" "r5900"))
+                  (const_string "yes")]
+              (const_string "no")))])
 
 (define_expand "<u>mulsidi3_64bit_mips16"
   [(set (match_operand:DI 0 "register_operand")
@@ -2082,7 +2176,7 @@
   "TARGET_64BIT && TARGET_MIPS16"
 {
   emit_insn (gen_<u>mulsidi3_64bit_split (operands[0], operands[1],
-					  operands[2], gen_reg_rtx (DImode)));
+					  operands[2], gen_reg_rtx (DImode), gen_reg_rtx (TImode)));
   DONE;
 })
 
@@ -2090,16 +2184,14 @@
   [(set (match_operand:DI 0 "register_operand")
 	(mult:DI (any_extend:DI (match_operand:SI 1 "register_operand"))
 		 (any_extend:DI (match_operand:SI 2 "register_operand"))))
-   (clobber (match_operand:DI 3 "register_operand"))]
+   (clobber (match_operand:DI 3 "register_operand"))
+   (clobber (match_operand:TI 4 "hilo_operand"))]
   ""
 {
-  rtx hilo;
-
-  hilo = gen_rtx_REG (TImode, MD_REG_FIRST);
-  emit_insn (gen_<u>mulsidi3_64bit_hilo (hilo, operands[1], operands[2]));
+  emit_insn (gen_<u>mulsidi3_64bit_hilo (operands[4], operands[1], operands[2]));
 
-  emit_move_insn (operands[0], gen_rtx_REG (DImode, LO_REGNUM));
-  emit_insn (gen_mfhidi_ti (operands[3], hilo));
+  emit_move_insn (operands[0], gen_rtx_REG (DImode, MD_REG_P ( REGNO (operands[4])) ? LO_REGNUM : LO1_REGNUM));
+  emit_insn (gen_mfhidi_ti (operands[3], operands[4]));
 
   if (ISA_HAS_EXT_INS)
     emit_insn (gen_insvdi (operands[0], GEN_INT (32), GEN_INT (32),
@@ -2120,16 +2212,24 @@
 })
 
 (define_insn "<u>mulsidi3_64bit_hilo"
-  [(set (match_operand:TI 0 "muldiv_target_operand" "=x")
+  [(set (match_operand:TI 0 "muldiv_target_operand" "=x,xwr")
 	(unspec:TI
 	  [(mult:DI
-	     (any_extend:DI (match_operand:SI 1 "register_operand" "d"))
-	     (any_extend:DI (match_operand:SI 2 "register_operand" "d")))]
+	     (any_extend:DI (match_operand:SI 1 "register_operand" "d,d"))
+	     (any_extend:DI (match_operand:SI 2 "register_operand" "d,d")))]
 	  UNSPEC_SET_HILO))]
   "TARGET_64BIT && !TARGET_FIX_R4000"
-  "mult<u>\t%1,%2"
-  [(set_attr "type" "imul")
-   (set_attr "mode" "SI")])
+  { return TARGET_MIPS5900 ? "mult<u>%H0\t%1,%2" : "mult<u>\t%1,%2"; }
+  [(set_attr "type" "imul,imul")
+   (set_attr "mode" "SI")
+   (set (attr "enabled")
+        (cond [(and (eq_attr "alternative" "0")
+                    (eq_attr "cpu" "!r5900"))
+                  (const_string "yes")
+               (and (eq_attr "alternative" "1")
+                    (eq_attr "cpu" "r5900"))
+                  (const_string "yes")]
+              (const_string "no")))])
 
 ;; See comment before the ISA_HAS_DMUL3 case in mips_mulsidi3_gen_fn.
 (define_insn "mulsidi3_64bit_dmul"
@@ -2177,7 +2277,7 @@
 	   (mult:DI
 	      (any_extend:DI (match_operand:SI 1 "register_operand" "d"))
 	      (any_extend:DI (match_operand:SI 2 "register_operand" "d")))))]
-  "!TARGET_64BIT && (ISA_HAS_MSAC || GENERATE_MADD_MSUB || ISA_HAS_DSP)"
+  "!TARGET_64BIT && !TARGET_MIPS5900 && (ISA_HAS_MSAC || GENERATE_MADD_MSUB || ISA_HAS_DSP)"
 {
   if (ISA_HAS_DSP_MULT)
     return "msub<u>\t%q0,%1,%2";
@@ -2446,12 +2546,12 @@
 ;; See the comment above <u>msubsidi4 for the relationship between
 ;; ISA_HAS_DSP and ISA_HAS_DSP_MULT.
 (define_insn "<u>maddsidi4"
-  [(set (match_operand:DI 0 "muldiv_target_operand" "=ka")
+  [(set (match_operand:DI 0 "muldiv_target_operand" "=ka,kawr")
 	(plus:DI
-	 (mult:DI (any_extend:DI (match_operand:SI 1 "register_operand" "d"))
-		  (any_extend:DI (match_operand:SI 2 "register_operand" "d")))
-	 (match_operand:DI 3 "muldiv_target_operand" "0")))]
-  "(TARGET_MAD || ISA_HAS_MACC || GENERATE_MADD_MSUB || ISA_HAS_DSP)
+	 (mult:DI (any_extend:DI (match_operand:SI 1 "register_operand" "d,d"))
+		  (any_extend:DI (match_operand:SI 2 "register_operand" "d,d")))
+	 (match_operand:DI 3 "muldiv_target_operand" "0,0")))]
+  "(TARGET_MAD || ISA_HAS_MACC || GENERATE_MADD_MSUB || ISA_HAS_DSP || TARGET_MIPS5900)
    && !TARGET_64BIT"
 {
   if (TARGET_MAD)
@@ -2460,13 +2560,23 @@
     return "madd<u>\t%q0,%1,%2";
   else if (GENERATE_MADD_MSUB || TARGET_MIPS5500)
     return "madd<u>\t%1,%2";
+  else if (TARGET_MIPS5900)
+    return "madd<u>%H0\t%1,%2";
   else
     /* See comment in *macc.  */
     return "%[macc<u>\t%@,%1,%2%]";
 }
-  [(set_attr "type" "imadd")
+  [(set_attr "type" "imadd,imadd")
    (set_attr "accum_in"	"3")
-   (set_attr "mode" "SI")])
+   (set_attr "mode" "SI")
+   (set (attr "enabled")
+        (cond [(and (eq_attr "alternative" "0")
+                    (eq_attr "cpu" "!r5900"))
+                  (const_string "yes")
+               (and (eq_attr "alternative" "1")
+                    (eq_attr "cpu" "r5900"))
+                  (const_string "yes")]
+              (const_string "no")))])
 
 ;; Floating point multiply accumulate instructions.
 
@@ -2698,7 +2808,7 @@
   [(set (match_operand:ANYF 0 "register_operand" "=f")
 	(div:ANYF (match_operand:ANYF 1 "const_1_operand" "")
 		  (match_operand:ANYF 2 "register_operand" "f")))]
-  "ISA_HAS_FP_RECIP_RSQRT (<MODE>mode) && flag_unsafe_math_optimizations"
+  "ISA_HAS_FP_RECIP_RSQRT (<MODE>mode) && !TARGET_MIPS5900 && flag_unsafe_math_optimizations"
 {
   if (TARGET_FIX_SB1)
     return "recip.<fmt>\t%0,%2\;mov.<fmt>\t%0,%0";
@@ -2734,10 +2844,10 @@
 })
 
 (define_insn_and_split "*divmod<mode>4"
-  [(set (match_operand:GPR 0 "register_operand" "=l")
-	(div:GPR (match_operand:GPR 1 "register_operand" "d")
-		 (match_operand:GPR 2 "register_operand" "d")))
-   (set (match_operand:GPR 3 "register_operand" "=d")
+  [(set (match_operand:GPR 0 "register_operand" "=l,lwl")
+	(div:GPR (match_operand:GPR 1 "register_operand" "d,d")
+		 (match_operand:GPR 2 "register_operand" "d,d")))
+   (set (match_operand:GPR 3 "register_operand" "=d,d")
 	(mod:GPR (match_dup 1)
 		 (match_dup 2)))]
   "ISA_HAS_<D>DIV && !TARGET_FIX_VR4120 && !TARGET_MIPS16"
@@ -2745,12 +2855,20 @@
   "&& reload_completed"
   [(const_int 0)]
 {
-  emit_insn (gen_divmod<mode>4_split (operands[3], operands[1], operands[2]));
+  emit_insn (gen_divmod<mode>4_split (operands[3], operands[1], operands[2], operands[0]));
   DONE;
 }
- [(set_attr "type" "idiv")
+ [(set_attr "type" "idiv,idiv")
   (set_attr "mode" "<MODE>")
-  (set_attr "insn_count" "2")])
+  (set_attr "insn_count" "2,2")
+  (set (attr "enabled")
+        (cond [(and (eq_attr "alternative" "0")
+                    (eq_attr "cpu" "!r5900"))
+                  (const_string "yes")
+               (and (eq_attr "alternative" "1")
+                    (eq_attr "cpu" "r5900"))
+                  (const_string "yes")]
+              (const_string "no")))])
 
 ;; Expand generates divmod instructions for individual division and modulus
 ;; operations.  We then rely on CSE to reuse earlier divmods where possible.
@@ -2771,7 +2889,7 @@
   "&& cse_not_expected"
   [(const_int 0)]
 {
-  emit_insn (gen_divmod<mode>4_split (operands[3], operands[1], operands[2]));
+  emit_insn (gen_divmod<mode>4_split (operands[3], operands[1], operands[2], operands[4]));
   emit_move_insn (operands[0], operands[4]);
   DONE;
 }
@@ -2799,10 +2917,10 @@
 })
 
 (define_insn_and_split "*udivmod<mode>4"
-  [(set (match_operand:GPR 0 "register_operand" "=l")
-	(udiv:GPR (match_operand:GPR 1 "register_operand" "d")
-		  (match_operand:GPR 2 "register_operand" "d")))
-   (set (match_operand:GPR 3 "register_operand" "=d")
+  [(set (match_operand:GPR 0 "register_operand" "=l,lwl")
+	(udiv:GPR (match_operand:GPR 1 "register_operand" "d,d")
+		  (match_operand:GPR 2 "register_operand" "d,d")))
+   (set (match_operand:GPR 3 "register_operand" "=d,d")
 	(umod:GPR (match_dup 1)
 		  (match_dup 2)))]
   "ISA_HAS_<D>DIV && !TARGET_MIPS16"
@@ -2810,12 +2928,20 @@
   "reload_completed"
   [(const_int 0)]
 {
-  emit_insn (gen_udivmod<mode>4_split (operands[3], operands[1], operands[2]));
+  emit_insn (gen_udivmod<mode>4_split (operands[3], operands[1], operands[2], operands[0]));
   DONE;
 }
-  [(set_attr "type" "idiv")
+  [(set_attr "type" "idiv,idiv")
    (set_attr "mode" "<MODE>")
-   (set_attr "insn_count" "2")])
+   (set_attr "insn_count" "2,2")
+   (set (attr "enabled")
+        (cond [(and (eq_attr "alternative" "0")
+                    (eq_attr "cpu" "!r5900"))
+                  (const_string "yes")
+               (and (eq_attr "alternative" "1")
+                    (eq_attr "cpu" "r5900"))
+                  (const_string "yes")]
+              (const_string "no")))])
 
 ;; See the comment above "divmod<mode>4_mips16" for the split timing.
 (define_insn_and_split "udivmod<mode>4_mips16"
@@ -2831,7 +2957,7 @@
   "cse_not_expected"
   [(const_int 0)]
 {
-  emit_insn (gen_udivmod<mode>4_split (operands[3], operands[1], operands[2]));
+  emit_insn (gen_udivmod<mode>4_split (operands[3], operands[1], operands[2], operands[4]));
   emit_move_insn (operands[0], operands[4]);
   DONE;
 }
@@ -2842,21 +2968,22 @@
 (define_expand "<u>divmod<mode>4_split"
   [(set (match_operand:GPR 0 "register_operand")
 	(any_mod:GPR (match_operand:GPR 1 "register_operand")
-		     (match_operand:GPR 2 "register_operand")))]
+		     (match_operand:GPR 2 "register_operand")))
+   (clobber (match_operand:GPR 3 "lo_operand"))]
   ""
 {
   rtx hilo;
 
   if (TARGET_64BIT)
     {
-      hilo = gen_rtx_REG (TImode, MD_REG_FIRST);
+      hilo = gen_rtx_REG (TImode, MD_REG_P ( REGNO (operands[3])) ? MD_REG_FIRST : MD1_REG_FIRST);
       emit_insn (gen_<u>divmod<mode>4_hilo_ti (hilo, operands[1],
 					       operands[2]));
       emit_insn (gen_mfhi<mode>_ti (operands[0], hilo));
     }
   else
     {
-      hilo = gen_rtx_REG (DImode, MD_REG_FIRST);
+      hilo = gen_rtx_REG (DImode, MD_REG_P ( REGNO (operands[3])) ? MD_REG_FIRST : MD1_REG_FIRST);
       emit_insn (gen_<u>divmod<mode>4_hilo_di (hilo, operands[1],
 					       operands[2]));
       emit_insn (gen_mfhi<mode>_di (operands[0], hilo));
@@ -2865,15 +2992,23 @@
 })
 
 (define_insn "<u>divmod<GPR:mode>4_hilo_<HILO:mode>"
-  [(set (match_operand:HILO 0 "muldiv_target_operand" "=x")
+  [(set (match_operand:HILO 0 "muldiv_target_operand" "=x,xwr")
 	(unspec:HILO
-	  [(any_div:GPR (match_operand:GPR 1 "register_operand" "d")
-			(match_operand:GPR 2 "register_operand" "d"))]
+	  [(any_div:GPR (match_operand:GPR 1 "register_operand" "d,d")
+			(match_operand:GPR 2 "register_operand" "d,d"))]
 	  UNSPEC_SET_HILO))]
   "ISA_HAS_<GPR:D>DIV"
-  { return mips_output_division ("<GPR:d>div<u>\t%.,%1,%2", operands); }
-  [(set_attr "type" "idiv")
-   (set_attr "mode" "<GPR:MODE>")])
+  { return mips_output_division (TARGET_MIPS5900 ? "<GPR:d>div<u>%H0\t%.,%1,%2" : "<GPR:d>div<u>\t%.,%1,%2", operands); }
+  [(set_attr "type" "idiv,idiv")
+   (set_attr "mode" "<GPR:MODE>")
+   (set (attr "enabled")
+        (cond [(and (eq_attr "alternative" "0")
+                    (eq_attr "cpu" "!r5900"))
+                  (const_string "yes")
+               (and (eq_attr "alternative" "1")
+                    (eq_attr "cpu" "r5900"))
+                  (const_string "yes")]
+              (const_string "no")))])
 
 ;; Integer division and modulus.
 
@@ -5109,26 +5244,42 @@
 ;; instead of MFHI.  This avoids both the normal MIPS III hi/lo hazards
 ;; and the errata related to -mfix-vr4130.
 (define_insn "mfhi<GPR:mode>_<HILO:mode>"
-  [(set (match_operand:GPR 0 "register_operand" "=d")
-	(unspec:GPR [(match_operand:HILO 1 "hilo_operand" "x")]
+  [(set (match_operand:GPR 0 "register_operand" "=d,d")
+	(unspec:GPR [(match_operand:HILO 1 "hilo_operand" "x,xwr")]
 		    UNSPEC_MFHI))]
   ""
-  { return ISA_HAS_MACCHI ? "<GPR:d>macchi\t%0,%.,%." : "mfhi\t%0"; }
-  [(set_attr "type" "mfhi")
-   (set_attr "mode" "<GPR:MODE>")])
+  { return ISA_HAS_MACCHI ? "<GPR:d>macchi\t%0,%.,%." : TARGET_MIPS5900 ? "mfhi%H1\t%0" : "mfhi\t%0"; }
+  [(set_attr "type" "mfhi,mfhi1")
+   (set_attr "mode" "<GPR:MODE>")
+   (set (attr "enabled")
+        (cond [(and (eq_attr "alternative" "0")
+                    (eq_attr "cpu" "!r5900"))
+                  (const_string "yes")
+               (and (eq_attr "alternative" "1")
+                    (eq_attr "cpu" "r5900"))
+                  (const_string "yes")]
+              (const_string "no")))])
 
 ;; Set the high part of a HI/LO value, given that the low part has
 ;; already been set.  See mips_hard_regno_mode_ok_p for the reason
 ;; why we can't just use (reg:GPR HI_REGNUM).
 (define_insn "mthi<GPR:mode>_<HILO:mode>"
-  [(set (match_operand:HILO 0 "register_operand" "=x")
-	(unspec:HILO [(match_operand:GPR 1 "reg_or_0_operand" "dJ")
-		      (match_operand:GPR 2 "register_operand" "l")]
+  [(set (match_operand:HILO 0 "register_operand" "=x,xwr")
+	(unspec:HILO [(match_operand:GPR 1 "reg_or_0_operand" "dJ,dJ")
+		      (match_operand:GPR 2 "register_operand" "l,lwl")]
 		     UNSPEC_MTHI))]
   ""
-  "mthi\t%z1"
-  [(set_attr "type" "mthi")
-   (set_attr "mode" "SI")])
+  { return TARGET_MIPS5900 ? "mthi%H0\t%z1" : "mthi\t%z1"; }
+  [(set_attr "type" "mthi,mthi1")
+   (set_attr "mode" "SI")
+   (set (attr "enabled")
+        (cond [(and (eq_attr "alternative" "0")
+                    (eq_attr "cpu" "!r5900"))
+                  (const_string "yes")
+               (and (eq_attr "alternative" "1")
+                    (eq_attr "cpu" "r5900"))
+                  (const_string "yes")]
+              (const_string "no")))])
 
 ;; Emit a doubleword move in which exactly one of the operands is
 ;; a floating-point register.  We can't just emit two normal moves
diff -rupNb gcc-5.3.0-libgcc/gcc/config/mips/predicates.md gcc-5.3.0-ps2/gcc/config/mips/predicates.md
--- gcc-5.3.0-libgcc/gcc/config/mips/predicates.md	2015-01-15 18:44:57.000000000 +0800
+++ gcc-5.3.0-ps2/gcc/config/mips/predicates.md	2016-03-27 18:05:58.000000000 +0800
@@ -244,11 +244,13 @@
 
 (define_predicate "lo_operand"
   (and (match_code "reg")
-       (match_test "REGNO (op) == LO_REGNUM")))
+       (ior (match_test "REGNO (op) == LO_REGNUM")
+            (match_test "REGNO (op) == LO1_REGNUM"))))
 
 (define_predicate "hilo_operand"
   (and (match_code "reg")
-       (match_test "MD_REG_P (REGNO (op))")))
+       (ior (match_test "MD_REG_P (REGNO (op))")
+            (match_test "MD1_REG_P (REGNO (op))"))))
 
 (define_predicate "fcc_reload_operand"
   (and (match_code "reg,subreg")
diff -rupNb gcc-5.3.0-libgcc/gcc/config.gcc gcc-5.3.0-ps2/gcc/config.gcc
--- gcc-5.3.0-libgcc/gcc/config.gcc	2015-09-10 22:17:53.000000000 +0800
+++ gcc-5.3.0-ps2/gcc/config.gcc	2016-03-27 20:04:47.575691096 +0800
@@ -2161,6 +2161,11 @@ mips64r5900-*-elf* | mips64r5900el-*-elf
 	tmake_file="mips/t-elf"
 	tm_defines="${tm_defines} MIPS_ISA_DEFAULT=3 MIPS_ABI_DEFAULT=ABI_N32"
 	;;
+mipsel-*-irx*)
+	tm_file="dbxelf.h elfos.h newlib-stdint.h ${tm_file} mips/elf.h"
+	tmake_file="mips/t-elf mips/dbx.h"
+	target_cpu_default=MASK_SOFT_FLOAT_ABI
+	;;
 mips64-*-elf* | mips64el-*-elf*)
 	tm_file="elfos.h newlib-stdint.h ${tm_file} mips/elf.h"
 	tmake_file="mips/t-elf"
diff -rupNb gcc-5.3.0-libgcc/libgcc/config.host gcc-5.3.0-ps2/libgcc/config.host
--- gcc-5.3.0-libgcc/libgcc/config.host	2016-03-27 18:01:36.707549193 +0800
+++ gcc-5.3.0-ps2/libgcc/config.host	2016-03-27 20:06:20.427692875 +0800
@@ -889,6 +889,9 @@ mips-*-elf* | mipsel-*-elf*)
 	fi
 	extra_parts="$extra_parts crti.o crtn.o"
 	;;
+mipsel-*-irx)
+	tmake_file="$tmake_file mips/t-elf"
+	;;
 mipsr5900-*-elf* | mipsr5900el-*-elf*)
 	tmake_file="$tmake_file mips/t-elf mips/t-crtstuff"
 	extra_parts="$extra_parts crti.o crtn.o"
